## c字符串
* 在 C 语言中，字符串实际上是使用 null 字符 '\0' 终止的一维字符数组。
* 示例：`char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};`
* 也可以写成：`char greeting[] = "Hello";`
* 针对字符数组，使用`char*`抽取其中的内容，才是现实指针运算的用途，但是要注意不要操作无意义的区域或者越界操作

## 指针
* c语言中所说的指针，以及我们平时使用的指针变量，其实是操作系统分配的资格虚拟地址

```html
//方法1
int* pointer = (int*)malloc(sizeof(int));
//方法2
int* pointer_2 = malloc(sizeof(int));
```

* 在`void*` 类型还未出现的时候，malloc返回的是 `char*` ,所以，为了防止错误，可以加上强制类型转换
* 任何类型的指针都可以与 `void*` 互相转换
* 因为 `malloc` ， `calloc` ， `realloc` ，的使用有很大的风险，所以使用时，最好对他们进行包装，可以选择宏包装，也可以选择函数包装
（这就解释了，PHP源代码中，分配内存的一些操作时，都是使用一些宏）
* c语言中，编译器中，不对数组做越界检查，所以是可以声明一个有 `N` 个数的数组 `arr`（&arr[N]），这种写法成了C99的一部分
* `free` 操作并不会将地址空间清空，有一部分原因是考虑到了性能消耗，因而实际上free只是将该段地址空间的前面一小部分置零（加标记）

## 预处理
* 宏，只是进行简单的展开或替换
* 宏定义中，最后的位置一般不加 `;`
* c语言标准中对于一个确定的程序语句，一个对象只能被修改一次，如果超过一次，那么结果是未定的，由编译器决定。如：`int res = (x>y++?x : y++);`
* 除此之外，`switch`，`for`，`&&`，`||`等中，都是可能造成这种问题
* 有时候，展开也能造成一些问题：

```c
#define MUL(x,y) (x*y)
...
int x=100,y=200;
int res = MUL(x+y,y);
```

* 一个表较好的解决办法是，将参数加上括号：`#define MUL(x,y) ((x)*(y))






