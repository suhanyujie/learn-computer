## 4.1
* 编写一个完整的TCP客户/服务程序所需的基本套接字函数

## 4.2 socket函数
* 创建套接字
* 它的返回值是一个非负整数，和"文件描述符"类似，它被称为"套接字描述符"。
* 为了得到这个描述符，socket函数只是指定了协议族和套接字类型（字节流、数据报或原始套接字）
* 地址族的常用值有：
>AF_INET
AF_INET6
AF_LOCAL Unix域套接字
AF_ROUTE 路由套接字
AF_KEY 秘钥套接字

* `AF_` 前缀表述地址族，`PF_` 前缀表示协议族

## 4.3 connect函数
* TCP客户使用connect函数来和服务器建立连接
* 如果是TCP套接字，调用connect函数将激发TCP的三路握手过程。而且仅在连接成功或者出错时才会返回
* 针对一个套接字，从CLOESED到SYN_SENT状态，成功则转为ESTABLISHED。若失败，则该套接字不再可用，必须将其关闭，对于这样的套接字，不能再次调用connect函数

## 4.4 bind函数
* 对于本地协议：它的作用是赋予一个套接字
* 对于网际网协议：协议地址是TCP或UDP端口号的组合

## 4.5 listen函数
* 它的函数原型是：

```c/c++
#include <sys/socket.h>
int listen(int sockfd, int backlog);
返回：若成功则为0，若出错则为-1
```

* 其中backlog参数，内核为任何一个给定的监听套接字维护两个对队列：
    * 未完成连接队列
    * 已完成连接队列
* 两队列只和不超过backlog（曾经的规定）
* 当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应以三路握手的第2个分节（服务器的SYN响应），其中捎带对客户SYN的ACK
* 此时，这一项一直保留在未完成连接队列中，直到三路握手的第3个分节到达或者该项超时为止。
* 如果三路握手正常完成，该项就从未完成链接队列到已完成连接队列的队尾。
* 当进程调用accept时，已完成连接队列中的队头将返回给进程，或者如果该队列为空，那么进程将被投入睡眠，直到TCP在该队列中放入下一项才唤醒它。
>当一个客户的SYN到达时，若这些队列是满的，TCP就忽略该分节，也就是不发送RST。这么做是因为：这种情况是暂时的，客户TCP将重发SYN，期望不久就能在这些队列中找到可用空间。

* 在三路握手之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为相应已连接套接字的接收缓冲区大小。

## 4.6 accept函数
* accept函数由TCP服务器调用，用于从已完成连接队列对头返回下一个已完成连接。如果已完成连接队列为空，那么进程就被投入睡眠（假定套接字为默认的阻塞方式）

```c/c++
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);
返回：若成功则为非负描述符；若出错，则为-1
```


