## 4.1
* 编写一个完整的TCP客户/服务程序所需的基本套接字函数

## 4.2 socket函数
* 创建套接字
* 它的返回值是一个非负整数，和"文件描述符"类似，它被称为"套接字描述符"。
* 为了得到这个描述符，socket函数只是指定了协议族和套接字类型（字节流、数据报或原始套接字）
* 地址族的常用值有：
>AF_INET
AF_INET6
AF_LOCAL Unix域套接字
AF_ROUTE 路由套接字
AF_KEY 秘钥套接字

* `AF_` 前缀表述地址族，`PF_` 前缀表示协议族

## 4.3 connect函数
* TCP客户使用connect函数来和服务器建立连接
* 如果是TCP套接字，调用connect函数将激发TCP的三路握手过程。而且仅在连接成功或者出错时才会返回
* 针对一个套接字，从CLOESED到SYN_SENT状态，成功则转为ESTABLISHED。若失败，则该套接字不再可用，必须将其关闭，对于这样的套接字，不能再次调用connect函数

## 4.4 bind函数
* 对于本地协议：它的作用是赋予一个套接字
* 对于网际网协议：协议地址是TCP或UDP端口号的组合

## 4.5 listen函数
* 它的函数原型是：

```c/c++
#include <sys/socket.h>
int listen(int sockfd, int backlog);
返回：若成功则为0，若出错则为-1
```

* 其中backlog参数，内核为任何一个给定的监听套接字维护两个对队列：
    * 未完成连接队列
    * 已完成连接队列
* 两队列只和不超过backlog（曾经的规定）
* 当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应以三路握手的第2个分节（服务器的SYN响应），其中捎带对客户SYN的ACK
* 此时，这一项一直保留在未完成连接队列中，直到三路握手的第3个分节到达或者该项超时为止。
* 如果三路握手正常完成，该项就从未完成链接队列到已完成连接队列的队尾。
* 当进程调用accept时，已完成连接队列中的队头将返回给进程，或者如果该队列为空，那么进程将被投入睡眠，直到TCP在该队列中放入下一项才唤醒它。
>当一个客户的SYN到达时，若这些队列是满的，TCP就忽略该分节，也就是不发送RST。这么做是因为：这种情况是暂时的，客户TCP将重发SYN，期望不久就能在这些队列中找到可用空间。

* 在三路握手之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为相应已连接套接字的接收缓冲区大小。

## 4.6 accept函数
* accept函数由TCP服务器调用，用于从已完成连接队列对头返回下一个已完成连接。如果已完成连接队列为空，那么进程就被投入睡眠（假定套接字为默认的阻塞方式）

```c/c++
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);
返回：若成功则为非负描述符；若出错，则为-1
```

* 如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接。
* 分清楚监听套接字和已连接套接字描述符
* 当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭

## 4.7 fork函数
* fork函数，调用一次，却返回两次
* fork在子进程中返回0 而不是父进程的进程id的原因在于：任何子进程都只有一个父进程，而子进程是可以通过调用getppid取得父进程的进程id。
* 相反，父进程可以有许多子进程，而且无法获取各个子进程的进程id。
* 如果父进程想要跟踪各个子进程的进程id，那么它必须每次记录调用fork的返回值
* 父进程调用fork之前打开的所有描述符在fork返回之后由子进程分享！
* 网络服务器利用这个特性：父进程调用accept之后调用fork函数。所接受的已连接套接字随后就在父进程与子进程之间共享。
* 通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字。

### 91页
* 一个TCP套接字调用close会导致发送一个FIN，随后是正常的TCP连接终止序列。
* 那么父进程对connfd调用close没有终止它与客户的连接呢？每个文件或套接字都有一个引用计数
* 引用计数在文件表项中维护，它是当前打开着的引用该文件或套接字的描述符的个数。
* socket返回后宇listenfd关联的文件表项的引用计数值为1，accept返回后与connfd关联的文件表项的引用计数值为1.
* 然而fork后，这两个描述符就在父进程与子进程间共享（也就是被复制）
* 因此，与这2个套接字相关联的文件表项各自的访问计数值均为2.
* 当父进程关闭connfd时，只是把相应的引用计数值从2减为1
* 该告诫自真正的清理和资源释放要等到其引用计数值到达0时才会发生。这会在子进程关闭connfd时发生。

## 4.9 close函数
* close函数用来关闭套接字，并终止TCP连接
* 它的原型如下：
>#include <unistd.h>
int clise(int sockfd);
返回：若成功则为0，异常则为-1

* 一旦调用完成后，立即返回到调用进程，此时该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或者write的第一个参数
* 可以设想一下，如果父进程对每个由accept返回的已连接套接字都不调用close，那么父进程最后将会耗尽可用描述符，因为任何进程任何时候可拥有的打开着的描述符通常是有限的
* 当子进程关闭已连接套接字时，它的引用技术将由2递减为1，这将妨碍TCP连接终止序列的发生，导致连接一直打开着

## 习题
### 4.1在4.4节中，我们说头文件<netinet/int.h>中定义的INADDR_常值是主机字节序的。我们应该如何辨别？
* 主机序分为2种：
>大端字节序（big-endian）：按照内存的增长方向，高位数据存储于低位内存中<br>
 小端字节序（little-endian）：按照内存的增长方向，高位数据存储于高位内存中

* 网络字节序其实就是标准化的字节序--大端字节序
* 网络字节序定义：收到的第一个字节被当作高位看待，这就要求发送端发送的第一个字节应当是高位。而在发送端发送数据时，发送的第一个字节是该数字在内存中起始地址对应的字节。可见多字节数值在发送前，在内存中数值应该以大端法存放。
* 所以，网络协议指定了通讯字节序：大端。只有在多字节数据处理时才需要考虑字节序，运行在同一台计算机上的进程相互通信时，一般不用考虑字节序，异构计算机之间通讯，需要转换自己的字节序为网络字节

