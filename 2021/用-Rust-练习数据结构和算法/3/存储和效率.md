>* 原文链接：https://www.packtpub.com/product/hands-on-data-structures-and-algorithms-with-rust/9781788995528
>* 译文来自：https://github.com/suhanyujie/learn-computer

# 存储和效率
## 堆栈
### Sized 和 Unsized
要使编译器将编写的代码转换为二进制格式，就需要知道每种类型的大小。正如我们前面讨论的，大小很重要，所以我们可以在处理堆栈时将其他类型放在顶部，如果大小不随着它所包含的数据（大小类型）而改变，这是很容易的。最好的例子是 u32：它使用 32 位（或 4 字节），无论是存储 0 还是 10000900。

当类型大小未知或动态大小时，情况就不是这样了，最常见的例子 `str`。根据字符数量的不同，该类型的大小会有很大的差异，这就是为什么它的实例通常是以切片的形式出现的原因。

切片通过把固定大小的引用（`&str`）及长度存储到堆中来解决大小问题。与指针类似，这是一个固定大小的映射前面提到的未知大小值的视图。每次创建某种类型的指针（`&`、`Rc`、`Box`、`Cell` 等）时，引用都会把长度和一些（固定大小）元数据一起存储。例如，当类型未知时，大小与未知大小的相关知识在使用 Rust 泛型时特别有用。

### 泛型
Rust 支持泛型，甚至允许我们强制校验某些 trait 的实现。这些约束既可以作为附加到函数定义的 where 子句中，也可以和冒号一起作为泛型类型：

```
fn my_generic_func<T: MyTrait>(t: T) {
    // 代码
}

// 等价于

fn my_generic_func<T>(t: T)
where
    T: MyTrait
{
    // 代码
}
```

此外，2018 版本中的 impl Trait 语法简化了输入和返回参数的单 trait 需求（执行静态而不是动态分发），从而消除了 Box 或长的类型约束（如前面代码段中的 MyTrait）。除非有多个 trait 实现（例如，`fn f(x：T) where T: Clone + Debug + MyTrait {}`，其中 impl Trait 语法允许我们将它们放在它们重要而显眼的地方，即参数列表中：

```
fn my_generic_func<T>(t: T) {
    // 代码。。。
}

// 等价于

fn my_generic_func <T: Sized>(t: T) {
    // 代码。。。
}
```

当使用泛型时，情况会更复杂一些。默认情况下，类型参数默认是 Sized（请参见前面的代码片段），这意味着它们不匹配 Unsized 类型。为了匹配这些，需要使用特殊的 `?Sized` 类型约束。此代码片段还展现了对传递引用时所做的调整：

```
fn my_generic_func<T: ?Sized>(t: &T) {
    // 代码。。。
}
```

但是，任何堆分配的引用都会有额外的开销来访问所包含的值。

### 访问 box
一次额外开销听起来不是很大，但这可能会产生很大的后果。这是一种在函数或线程之间共享所有权与很多数据放到 CPU 缓存中所做的权衡，因为指针使数据本地化更加困难。堆分配本身是一种昂贵的操作，减少这种内存分配会提升很大的性能。

此外，如果编译器仍然在某些地方引用它，编译器就无法对它解引用 —— 当一个程序大而复杂时，这种问题尤为突出。类似于 C# 或 Java 中的 orphaned 对象，Rust 中的 Rc 引用很容易被遗忘，从而导致内存泄漏。因此，建议仅在需要时再使用堆内存。

在 Rust 中进行装箱操作时，有一个重要建议是“对象组合优于类继承”。在没有类继承的情况下，选择显然是使用对象组合。考虑到您还应该“面向接口编程而不是面向实现”（同上），通常强烈推荐在 struct 中使用 trait，而不是直接地实现。

为了使用这种架构，Rust 要求我们将 trait 的实现放到 `Box<dyn TheTrait>` 中，这样使其处理、测试和推导更加困难。trait 对象会使编译器进行动态分发，这比默认的静态分发要慢很多。

除了泛型之外，这个问题没有默认的解决方案。Rust 2018 版本的 impl 特性缓解了函数参数和返回值的这个问题，但不能用于字段类型。

到目前为止，最好的选择似乎是使用具体的类型而不是 trait 来避免多个解引用操作 —— 只要对更改进行重构似乎是可行的。如果您创建了一个库，泛型是提高性能和灵活性的更好方法。


