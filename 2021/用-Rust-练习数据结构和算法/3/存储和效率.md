>* 原文链接：https://www.packtpub.com/product/hands-on-data-structures-and-algorithms-with-rust/9781788995528
>* 译文来自：https://github.com/suhanyujie/learn-computer

# 存储和效率
## 堆栈
### Sized 和 Unsized
要使编译器将编写的代码转换为二进制格式，就需要知道每种类型的大小。正如我们前面讨论的，大小很重要，所以我们可以在处理堆栈时将其他类型放在顶部，如果大小不随着它所包含的数据（大小类型）而改变，这是很容易的。最好的例子是 u32：它使用 32 位（或 4 字节），无论是存储 0 还是 10000900。

当类型大小未知或动态大小时，情况就不是这样了，最常见的例子 `str`。根据字符数量的不同，该类型的大小会有很大的差异，这就是为什么它的实例通常是以切片的形式出现的原因。

切片通过把固定大小的引用（`&str`）及长度存储到堆中来解决大小问题。与指针类似，这是一个固定大小的映射前面提到的未知大小值的视图。每次创建某种类型的指针（`&`、`Rc`、`Box`、`Cell` 等）时，引用都会把长度和一些（固定大小）元数据一起存储。例如，当类型未知时，大小与未知大小的相关知识在使用 Rust 泛型时特别有用。

### 泛型
Rust 支持泛型，甚至允许我们强制校验某些 trait 的实现。这些约束既可以作为附加到函数定义的 where 子句中，也可以和冒号一起作为泛型类型：

```
fn my_generic_func<T: MyTrait>(t: T) {
    // 代码
}

// 等价于

fn my_generic_func<T>(t: T)
where
    T: MyTrait
{
    // 代码
}
```

此外，2018 版本中的 impl Trait 语法简化了输入和返回参数的单 trait 需求（执行静态而不是动态分发），从而消除了 Box 或长的类型约束（如前面代码段中的 MyTrait）。除非有多个 trait 实现（例如，`fn f(x：T) where T: Clone + Debug + MyTrait {}`，其中 impl Trait 语法允许我们将它们放在它们重要而显眼的地方，即参数列表中：

```
fn my_generic_func<T>(t: T) {
    // 代码。。。
}

// 等价于

fn my_generic_func <T: Sized>(t: T) {
    // 代码。。。
}
```

当使用泛型时，情况会更复杂一些。默认情况下，类型参数默认是 Sized（请参见前面的代码片段），这意味着它们不匹配 Unsized 类型。为了匹配这些，需要使用特殊的 `?Sized` 类型约束。此代码片段还显示了对传递引用时所做的调整：

```
fn my_generic_func<T: ?Sized>(t: &T) {
    // 代码。。。
}
```
