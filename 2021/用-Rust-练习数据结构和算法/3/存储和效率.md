>* 原文链接：https://www.packtpub.com/product/hands-on-data-structures-and-algorithms-with-rust/9781788995528
>* 译文来自：https://github.com/suhanyujie/learn-computer

# 存储和效率
## 堆栈
### Sized 和 Unsized
要使编译器将编写的代码转换为二进制格式，就需要知道每种类型的大小。正如我们前面讨论的，大小很重要，所以我们可以在处理堆栈时将其他类型放在顶部，如果大小不随着它所包含的数据（大小类型）而改变，这是很容易的。最好的例子是 u32：它使用 32 位（或 4 字节），无论是存储 0 还是 10000900。

当类型大小未知或动态大小时，情况就不是这样了，最常见的例子 `str`。根据字符数量的不同，该类型的大小会有很大的差异，这就是为什么它的实例通常是以切片的形式出现的原因。

切片通过把固定大小的引用（`&str`）及长度存储到堆中来解决大小问题。与指针类似，这是一个固定大小的映射前面提到的未知大小值的视图。每次创建某种类型的指针（`&`、`Rc`、`Box`、`Cell` 等）时，引用都会把长度和一些（固定大小）元数据一起存储。例如，当类型未知时，大小与未知大小的相关知识在使用 Rust 泛型时特别有用。

### 泛型
Rust 支持泛型，甚至允许我们强制校验某些 trait 的实现。这些约束既可以作为附加到函数定义的 where 子句中，也可以和冒号一起作为泛型类型：

```
fn my_generic_func<T: MyTrait>(t: T) {
    // 代码
}

// 等价于

fn my_generic_func<T>(t: T)
where
    T: MyTrait
{
    // 代码
}
```

此外，2018 版本中的 impl Trait 语法简化了输入和返回参数的单 trait 需求（执行静态而不是动态分发），从而消除了 Box 或长的类型约束（如前面代码段中的 MyTrait）。除非有多个 trait 实现（例如，`fn f(x：T) where T: Clone + Debug + MyTrait {}`，其中 impl Trait 语法允许我们将它们放在它们重要而显眼的地方，即参数列表中：

```
fn my_generic_func<T>(t: T) {
    // 代码。。。
}

// 等价于

fn my_generic_func <T: Sized>(t: T) {
    // 代码。。。
}
```

当使用泛型时，情况会更复杂一些。默认情况下，类型参数默认是 Sized（请参见前面的代码片段），这意味着它们不匹配 Unsized 类型。为了匹配这些，需要使用特殊的 `?Sized` 类型约束。此代码片段还展现了对传递引用时所做的调整：

```
fn my_generic_func<T: ?Sized>(t: &T) {
    // 代码。。。
}
```

但是，任何堆分配的引用都会有额外的开销来访问所包含的值。

### 访问 box
一次额外开销听起来不是很大，但这可能会产生很大的后果。这是一种在函数或线程之间共享所有权与很多数据放到 CPU 缓存中所做的权衡，因为指针使数据本地化更加困难。堆分配本身是一种昂贵的操作，减少这种内存分配会提升很大的性能。

此外，如果编译器仍然在某些地方引用它，编译器就无法对它解引用 —— 当一个程序大而复杂时，这种问题尤为突出。类似于 C# 或 Java 中的 orphaned 对象，Rust 中的 Rc 引用很容易被遗忘，从而导致内存泄漏。因此，建议仅在需要时再使用堆内存。

在 Rust 中进行装箱操作时，有一个重要建议是“对象组合优于类继承”。在没有类继承的情况下，选择显然是使用对象组合。考虑到您还应该“面向接口编程而不是面向实现”（同上），通常强烈推荐在 struct 中使用 trait，而不是直接地实现。

为了使用这种架构，Rust 要求我们将 trait 的实现放到 `Box<dyn TheTrait>` 中，这样使其处理、测试和推导更加困难。trait 对象会使编译器进行动态分发，这比默认的静态分发要慢很多。

除了泛型之外，这个问题没有默认的解决方案。Rust 2018 版本的 impl 特性缓解了函数参数和返回值的这个问题，但不能用于字段类型。

到目前为止，最好的选择似乎是使用具体的类型而不是 trait 来避免多个解引用操作 —— 只要对更改进行重构似乎是可行的。如果您创建了一个库，泛型是提高性能和灵活性的更好方法。


## 可变存储
GC（垃圾回收器）大大简化了数据的可变性，因此，带 GC 的这些语言中，大多不需要一个特定的修改器来实现变量的可变性。虽然这种垃圾回收机制以牺牲“清理内存的运行时”为代价，但不必关心变量是否可变，这是非常方便的。它允许开发人员专注于他们自己业务逻辑的实现。

那么，为什么 Rust（以及许多函数式语言）会提到这个概念呢？

### 状态和推导

对象的状态本质上是其字段在特定时间所拥有的值。改变这个状态由对象本身通过已定义的行为（称为方法）来完成的。这些状态的变化需要可变性。在它们的生命周期中，大多数对象会多次改变状态，由于这发生在运行时，你可能注意到自己经常沮丧地查看对象的调试打印，并思考，“这个值是如何到达到这里的？”

不可变数据结构通过不能更改其内容来做到这一点，因此当你查看对象时，它都有完全正确的值。众所周知的是，大多数变量是不需要可变的，除非存在资源约束，否则建议创建一个相同的新实例。这个原则被称为“写时复制”（copy-on-write），它提高了可读性，从而更好地维护。

使用“写时复制”的最常见地类型是 String —— 这种类型几乎在哦所有语言中都有。该类型包装字节数组，并使用提供的字符集(通常是UTF-8)对其进行编解码，如果修改了字符，该字节数组会发生拷贝并保存修改。我们经常这样做，以至于字符串分配经常有性能缺陷。

Rust 标准中，有一个 Cow 枚举（`std::borrow::Cow`），当发生变化或者被要求转移所有权时，发自动进行 clone。更详细的介绍可以参考官方文档：https://doc.rust-lang.org/std/borrow/enum.Cow.html

写时复制的原理也可以在文件系统中找到类似的影子（例如，在 ZFS 或 BRTFS 中），并以运行时资源为代价提供不可变性和可变性。这是可维护性和性能之间的一种权衡。持久性数据结构也采用了类似的概念，它可以实现部分持久化或完全持久化，并且仍然是不可变的。

### 并发和性能
在多线程场景中，拥有更容易推导和不可变状态的代码更为重要。这可以防止所谓的异常（或副作用），即在依赖的线程之外改变对象的状态。

锁通常在更改共享对象的状态时使用——它们保护关键部分的数据，只有一个线程可以在任何给定的时间修改关键部分数据。其他线程必须“排队”，并等待锁被释放才能访问该数据。在 Rust 中，这被称为 mutex。

以下场景不适合使用锁和互斥区域：
* 它们必须按照正确的顺序（获取和释放）。
* 当一个线程在互斥锁区域中出现恐慌时会发生什么？
* 它们很难无缝地集成到它们所保护的程序的部分中。
* 它们是性能的瓶颈。

不可变性是避免这些问题的简单方法，有许多不可变的数据结构 crate 可用，其中有一个是将数据持久化的 crate 叫 Rust Persistent Data Struct —— (RPDS)(https://crates.io/crates/rpds)，它利用版本控制的写时复制方法来捕获状态变化。由于这些更改相互构建在一起，线程可以完整地读取一个持久化的对象状态，而无需等待锁。

>无锁数据结构（Lock-free data structures）是一种个特殊的数据结构，它实现起来非常具有挑战性。这些数据结构使用原子操作来修改重要部件（例如，栈中的头指针），从而在没有锁的前提下实现优异的性能。

>持久化数据结构（Persistent data structures）是指创建与传统数据结构一样高效和可变的数据结构，但更适合并发时使用。它是通过保持原始数据不可变以及版本化的数据集合来实现的。

数据不可变的概念在函数式编程中是一种非常好的范式。函数式编程是建立在数学函数原理的基础上的。一个函数可以描述是两组数据(通常是 X 和 Y )的关系，其中 X 可以通过函数计算得到一个 Y。

## 总结
当我们常使用面向对象编程时，trait 对象也是一种面向接口编程而非面向实现。然而，它们有性能开销，即动态分发，这是在可维护性和性能之间的一种权衡。

除了移动语义之外，Rust 还可以在需要时复制和克隆变量。对于已知 sized 的值的情况，复制执行深度拷贝；未知大小的值需要可以克隆的引用。在对不可变类型的数据使用写时复制时，经常遇到使用这些操作。在设计数据结构时，要做出合适的选择，在任何给定的时间能够推理对象的状态并避免数据竞争条件，但必须为每个更改创建一个副本，这是设计数据结构时的另一个重要的权衡。

这种权衡将在下一章中详细讲解，到时候我们处理数据列表，如单链表、双链表和动态数组等。

